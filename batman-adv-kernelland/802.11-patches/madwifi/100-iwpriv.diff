Index: madwifi/net80211/ieee80211_ioctl.h
===================================================================
--- madwifi.orig/net80211/ieee80211_ioctl.h	2007-09-07 20:16:17.000000000 +0200
+++ madwifi/net80211/ieee80211_ioctl.h	2007-09-07 19:55:12.000000000 +0200
@@ -246,7 +246,7 @@
 	u_int8_t im_ssid[IEEE80211_NWID_LEN];
 };
 
-/* 
+/*
  * MAC ACL operations.
  */
 enum {
@@ -604,6 +604,7 @@
 	IEEE80211_PARAM_DROPUNENC_EAPOL		= 60,	/* drop unencrypted eapol frames */
  	IEEE80211_PARAM_SHPREAMBLE		= 61,	/* Short Preamble */
 	IEEE80211_PARAM_DUMPREGS		= 62,   /* Pretty printed dump of Atheros hardware registers */
+	IEEE80211_PARAM_BATMAN			= 63,   /* enable/disable batman meshing mode */
 };
 
 #define	SIOCG80211STATS			(SIOCDEVPRIVATE+2)
Index: madwifi/net80211/ieee80211_wireless.c
===================================================================
--- madwifi.orig/net80211/ieee80211_wireless.c	2007-09-07 20:16:14.000000000 +0200
+++ madwifi/net80211/ieee80211_wireless.c	2007-09-08 00:08:31.000000000 +0200
@@ -213,7 +213,7 @@
 
 			/*
 			 * Set key contents.  This interface only supports WEP.
-			 * Indicate intended key index.			 
+			 * Indicate intended key index.
 			 */
 			k->wk_keyix = kix;
 			if (ieee80211_crypto_newkey(vap, IEEE80211_CIPHER_WEP,
@@ -495,10 +495,10 @@
 	if (vap->iv_opmode == IEEE80211_M_WDS)
 		IEEE80211_ADDR_COPY(vap->wds_mac, &ap_addr->sa_data);
 
-	/* 
-	 * zero address corresponds to 'iwconfig ath0 ap off', which means 
+	/*
+	 * zero address corresponds to 'iwconfig ath0 ap off', which means
 	 * enable automatic choice of AP without actually forcing a
-	 * reassociation.  
+	 * reassociation.
 	 *
 	 * broadcast address corresponds to 'iwconfig ath0 ap any', which
 	 * means scan for the current best AP.
@@ -756,8 +756,8 @@
 			ic->ic_set_channel(ic);
 		}
 	} else if(vap->iv_opmode == IEEE80211_M_HOSTAP) {
-		/* Need to use channel switch announcement on beacon if we are 
-		 * up and running.  We use ic_set_channel directly if we are 
+		/* Need to use channel switch announcement on beacon if we are
+		 * up and running.  We use ic_set_channel directly if we are
 		 * "running" but not "up".  Otherwise, iv_des_chan will take
 		 * effect when we are transitioned to RUN state later. */
 		if(IS_UP(vap->iv_dev)) {
@@ -960,9 +960,9 @@
 		}
 	}
 
-	/* Atheros' RSSI value is SNR: 0 -> 60 for old chipsets. Range 
-	 * for newer chipsets is unknown. This value is arbitarily chosen 
-	 * to give an indication that full rate will be available and to be 
+	/* Atheros' RSSI value is SNR: 0 -> 60 for old chipsets. Range
+	 * for newer chipsets is unknown. This value is arbitarily chosen
+	 * to give an indication that full rate will be available and to be
 	 * a practicable maximum. */
 	range->max_qual.qual  = 70;
 #if WIRELESS_EXT >= 19
@@ -1148,7 +1148,7 @@
 		IEEE80211_DPRINTF(vap, IEEE80211_MSG_DEBUG,
 			"%s: disabled iw_spy threshold\n", __func__);
 	} else {
-		/* We are passed a signal level/strength - calculate 
+		/* We are passed a signal level/strength - calculate
 		 * corresponding RSSI values */
 		/* XXX: We should use current noise value. */
 		vap->iv_spy.thr_low = threshold.low.level + ATH_DEFAULT_NOISE;
@@ -1236,7 +1236,7 @@
 	struct ieee80211vap *vap = dev->priv;
 	struct ieee80211com *ic = vap->iv_ic;
 
-	/* XXX: These values, flags, and caps do not seem to be used elsewhere 
+	/* XXX: These values, flags, and caps do not seem to be used elsewhere
 	 * at all? */
 
 	if ((ic->ic_caps & IEEE80211_C_PMGT) == 0)
@@ -2308,7 +2308,7 @@
 	case IEEE80211_PARAM_WMM:
 		if (ic->ic_caps & IEEE80211_C_WME){
 			retv = ENETRESET;	/* Renegotiate for capabilities */
-			
+
 			if (value) {
 				/* All TKIP keys need resetting to use software MIC.
 				 * They aren't, so this is disabled.
@@ -2321,11 +2321,11 @@
 				}
 			} else {
 				vap->iv_flags &= ~IEEE80211_F_WME;
-				
+
 				{
 					struct ieee80211vap *v = NULL;
 					int all = 1;
-					
+
 					TAILQ_FOREACH(v, &vap->iv_ic->ic_vaps, iv_next) {
 						if (v->iv_flags & IEEE80211_F_WME) {
 							all = 0;
@@ -2386,10 +2386,10 @@
 		if (vap->iv_ath_cap != caps) {
 			if ((vap->iv_ath_cap ^ caps) & IEEE80211_ATHC_TURBOP) {
 				/* no turbo and XR at the same time */
-				if ((caps & IEEE80211_ATHC_TURBOP) && 
+				if ((caps & IEEE80211_ATHC_TURBOP) &&
 						(caps & IEEE80211_ATHC_XR))
 					return -EINVAL;
-				if (ieee80211_set_turbo(dev, 
+				if (ieee80211_set_turbo(dev,
 						(caps & IEEE80211_ATHC_TURBOP)))
 					return -EINVAL;
 				ieee80211_scan_flush(ic);
@@ -2627,6 +2627,15 @@
 		ieee80211_dump_registers(dev, info, w, extra);
 		break;
 #endif /* #ifdef ATH_REVERSE_ENGINEERING */
+	case IEEE80211_PARAM_BATMAN:
+		if (value) {
+			if (batman_ops != NULL)
+				retv = - batman_ops->attach(2);
+		} else {
+			if (batman_ops != NULL)
+				retv = - batman_ops->deattach(2);
+		}
+		break;
 	default:
 		retv = EOPNOTSUPP;
 		break;
@@ -2639,7 +2648,7 @@
 		vap->iv_xrvap->iv_ath_cap &= IEEE80211_ATHC_XR;
 	}
 	/*
-	 * do not reset the xr vap , which is automatically 
+	 * do not reset the xr vap , which is automatically
 	 * reset by the state machine now.
 	 */
 	if (!vap->iv_xrvap || (vap->iv_xrvap && !(vap->iv_flags & IEEE80211_F_XR))) {
@@ -3320,7 +3329,7 @@
 
 	kix = dk->idk_keyix;
 
-	/* XXX: This cast can be removed when struct ieee80211req_del_key is 
+	/* XXX: This cast can be removed when struct ieee80211req_del_key is
 	 * fixed. */
 	if (dk->idk_keyix == (u_int8_t) IEEE80211_KEYIX_NONE) {
 		struct ieee80211_node *ni;
@@ -3520,7 +3529,7 @@
 	if (IEEE80211_ADDR_NULL(vap->wds_mac))
 		return 0;
 
-	/* Compare suplied MAC address with WDS MAC of this interface 
+	/* Compare suplied MAC address with WDS MAC of this interface
 	 * remove when mac address is known
 	 */
 	if (memcmp(vap->wds_mac, sa->sa_data, IEEE80211_ADDR_LEN) == 0) {
@@ -4454,14 +4463,14 @@
 	return ieee80211_ioctl_setparam(dev, NULL, NULL, (char*)args);
 }
 
-/* 
+/*
  * If this function is invoked it means someone is using the wireless extensions
  * API instead of the private madwifi ioctls.  That's fine.  We translate their
- * request into the format used by the private ioctls.  Note that the 
- * iw_request_info and iw_param structures are not the same ones as the 
+ * request into the format used by the private ioctls.  Note that the
+ * iw_request_info and iw_param structures are not the same ones as the
  * private ioctl handler expects.  Luckily, the private ioctl handler doesn't
- * do anything with those at the moment.  We pass NULL for those, because in 
- * case someone does modify the ioctl handler to use those values, a null 
+ * do anything with those at the moment.  We pass NULL for those, because in
+ * case someone does modify the ioctl handler to use those values, a null
  * pointer will be easier to debug than other bad behavior.
  */
 static int
@@ -4840,7 +4849,7 @@
 
 	/* TODO This memcmp for the broadcast address seems hackish, but
 	 * mimics what wpa supplicant was doing.  The wpa supplicant comments
-	 * make it sound like they were having trouble with 
+	 * make it sound like they were having trouble with
 	 * IEEE80211_IOCTL_SETKEY and static WEP keys.  It might be worth
 	 * figuring out what their trouble was so the rest of this function
 	 * can be implemented in terms of ieee80211_ioctl_setkey */
@@ -5266,6 +5275,8 @@
 	  0, IW_PRIV_TYPE_APPIEBUF, "getiebuf" },
 	{ IEEE80211_IOCTL_FILTERFRAME,
 	  IW_PRIV_TYPE_FILTER , 0, "setfilter" },
+	{ IEEE80211_PARAM_BATMAN,
+	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "batman" },
 
 #ifdef ATH_REVERSE_ENGINEERING
 	/*
Index: madwifi/net80211/ieee80211_linux.c
===================================================================
--- madwifi.orig/net80211/ieee80211_linux.c	2007-09-07 23:57:30.000000000 +0200
+++ madwifi/net80211/ieee80211_linux.c	2007-09-08 00:09:31.000000000 +0200
@@ -956,6 +956,12 @@
 }
 EXPORT_SYMBOL(ether_sprintf);		/* XXX */
 
+/*
+ * Hooks for batman functions
+ */
+struct batman_ops *batman_ops = NULL;
+EXPORT_SYMBOL(batman_ops);
+
 /* Function to handle the device event notifications.
  * If the event is a NETDEV_CHANGENAME, and is for an interface
  * we are taking care of, then we want to remove its existing
Index: madwifi/net80211/ieee80211_linux.h
===================================================================
--- madwifi.orig/net80211/ieee80211_linux.h	2007-09-07 23:47:16.000000000 +0200
+++ madwifi/net80211/ieee80211_linux.h	2007-09-08 00:09:26.000000000 +0200
@@ -55,15 +55,15 @@
 #endif
 
 /*
- * The RSSI values reported in the TX/RX descriptors in the driver are the SNR 
+ * The RSSI values reported in the TX/RX descriptors in the driver are the SNR
  * expressed in dBm. Thus 'rssi' is signal level above the noise floor in dBm.
  *
- * Noise is measured in dBm and is negative unless there is an unimaginable 
- * level of RF noise. 
+ * Noise is measured in dBm and is negative unless there is an unimaginable
+ * level of RF noise.
  *
  * The signal level is noise + rssi.
  *
- * Note that the iw_quality values are 1 byte, and can be signed, unsigned or 
+ * Note that the iw_quality values are 1 byte, and can be signed, unsigned or
  * negative depending on context.
  *
  */
@@ -113,14 +113,14 @@
 
 /* Locking */
 /* NB: beware, spin_is_locked() is not usefully defined for !(DEBUG || SMP)
- * because spinlocks do not exist in this configuration. Instead IRQs 
+ * because spinlocks do not exist in this configuration. Instead IRQs
  * or pre-emption are simply disabled, as this is all that is needed.
  */
 
 /*
  * Beacon handler locking definitions.
- * Beacon locking 
- * UAPSD locking 
+ * Beacon locking
+ * UAPSD locking
  */
 typedef spinlock_t ieee80211com_lock_t;
 #define	IEEE80211_LOCK_INIT(_ic, _name)				\
@@ -576,4 +576,10 @@
 	struct net_device *);
 struct ieee80211vap *ieee80211_create_vap(struct ieee80211com *, char *,
 	struct net_device *, int, int);
+
+struct batman_ops {
+	int (*attach) (int);
+	int (*deattach) (int);
+};
+extern struct batman_ops *batman_ops;
 #endif /* _NET80211_IEEE80211_LINUX_H_ */
